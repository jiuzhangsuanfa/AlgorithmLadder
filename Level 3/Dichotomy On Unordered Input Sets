# 无序输入集上的二分法(Dichotomy On Unordered Input Sets)

二分法与数组是否排序无关，之前我们学习了如何在有序数组上使用二分法，我们同样可以在无序数组上使用二分法。下面是二分法在无序输入集上的应用。

## [寻找峰值(Find Peak Element)](https://www.lintcode.com/problem/75/)

我们需要在一组波浪形的数组中寻找任意的局部峰值。

为了使峰值一定存在，我们对数组做出以下规定

* 相邻位置的数字是不同的

* $A[0] < A[1] 且 A[n-2] > A[n-1]$

假设$P$是峰值的位置，即$P$点满足$A[P] > A[P-1]$且$A[P] > A[P+1]$

相邻位置的数字是不同的，使得不会出现如$[1,2,2,1]$形式的平顶峰

图1

$A[0] < A[1] 且 A[n-2] > A[n-1]$，就意味两端都是向中间上升的趋势。

两端都向中间下降，可能没有山峰

图2

只有一端向中间上升，可能没有山峰

图3

两端都是向中间上升的趋势，一定有山峰

图4

**数学证明：**
$A[0] < A[1] 且 A[n-2] > A[n-1]$ 等价于在$0$处的导数$f'(0) > 0$ 且 在$n-2$处的导数$f'(n-2) < 0$，那么在$0$到$n-2$中一定存在局部极值。

以数组$[1,2,1,3,4,5,7,6]$为例，存在两个峰值$2$和$7$他们的下标分别为$1$和$6$。

图5

那么我们如何判断是否存在峰值点呢？与上边的数学证明峰值存在问题同理，当左端点为上升趋势，右端点为下降趋势时，在左右端点之间一定存在一个满足条件的峰值点。因此，我们可以根据middle点左右两侧的趋势和左右端点的趋势进行二分查找。

middle左右分别存在上升和下降两种趋势的可能性，下面我们对这四种情况分别进行讨论。

1. 当middle左降右降时，middle的左半区域就形成了先上升后下降的趋势，则左边存在峰值；
2. 当middle左升右升时，middle的右半区域就形成了先上升后下降的趋势，则右边存在峰值；
3. 当middle左降右升时，左边和右边都存在峰值；
4. 当middle左升右降时，不能判断左右是否存在峰值，但是middle点本身即为一个峰值点。

图6

java代码

```java
if (A[mid] < A[mid - 1] && A[mid] < A[mid + 1]) {
    end = mid;
    // start = mid;
} else if (A[mid] < A[mid - 1] && A[mid] > A[mid + 1]) {
    end = mid;
} else if (A[mid] > A[mid - 1] && A[mid] < A[mid + 1]) {
    start = mid;
} else if (A[mid] > A[mid - 1] && A[mid] > A[mid + 1]) {
    return mid;
}
```

不同情况有相同的处理方式，进行归纳合并，最终形成完整代码

```java
public class Solution {
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    public int findPeak(int[] A) {
        // 峰值不可能在两端，所以二分查找峰值的范围为[1, A.length - 2]
        int start = 1;
        int end = A.length - 2;
        while (start + 1 < end) {
            // 如果mid向左上方倾斜，选择左半边
            int mid = start + (end - start) / 2;
            if (A[mid] < A[mid - 1]) {
                end = mid;
            }
            // 如果mid向右上方倾斜，选右半边
            else if (A[mid] < A[mid + 1]) {
                start = mid;
            }
            // 如果mid为峰值，选返回
            else {
                return mid;
            }
        }
        // 因为已经证明一定存在峰值，所以在start和end中选择较大的那一个
        return A[start] < A[end] ? end : start;
```

python代码

```python
class Solution:
    """
    @param A: An integers array.
    @return: return any of peek positions.
    """
    def findPeak(self, A):
        # 峰值不可能在两端，所以二分查找峰值的范围为[1, A.length - 2]
        start = 1
        end = len(A) - 2
        while start + 1 < end:
            mid = start + (end - start) // 2
            # 如果mid向左上方倾斜，选择左半边
            if A[mid] < A[mid - 1]:
                end = mid
            # 如果mid向右上方倾斜，选右半边
            elif A[mid] < A[mid + 1]:
                start = mid
            # 如果mid为峰值，选返回
            else:
                return mid
        # 因为已经证明一定存在峰值，所以在start和end中选择较大的那一个
        return end if A[start] < A[end] else start
```

**拓展：** 我们无法使用二分法在$O(logn)$的时间复杂度内求得全局的峰值。无序的数组上没有规律，我们只能做到$O(n)$的时间复杂度。若是寻找所有的峰的方法寻找，因为存在如$[1,2,1,2,...,1,2,1]$的情况。使得存在接近$\frac{n}{2}$个峰，光寻找峰都需要$O(\frac{n}{2})$的时间复杂度，排除。

<!-- TODO:
1.标题的英文修改
2.图片上传 -->
